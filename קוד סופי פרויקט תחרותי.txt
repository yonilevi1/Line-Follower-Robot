#include <Arduino.h>
#include <cmath>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <Preferences.h>

// ----------------------------------------------------
// הגדרות כלליות
// ----------------------------------------------------
const char* DEV_NAME = "ESP32_Pro_Racer";
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"

const unsigned long PID_INTERVAL_MS = 10; 

// ----------------------------------------------------
// חיישנים (CNY70)
// ----------------------------------------------------
const int PIN_S_L = 32;
const int PIN_S_C = 33;
const int PIN_S_R = 34; 

// כיול (RAW 0..4095)
int BLACK_L = 0,    WHITE_L = 4095;
int BLACK_C = 0,    WHITE_C = 4095;
int BLACK_R = 0,    WHITE_R = 4095;

// סף זיהוי קו (0..1000)
int LINE_SEEN_TH = 300;

// ----------------------------------------------------
// מנועים: L298N
// ----------------------------------------------------
// צד שמאל
const int L_EN    = 13; // PWM (EN_A + EN_B)
const int L_DIR_1 = 12; // (IN1 + IN4)
const int L_DIR_2 = 14; // (IN2 + IN3)

// צד ימין
const int R_EN    = 25; // PWM (EN_A + EN_B)
const int R_DIR_1 = 26; // (IN1 + IN4)
const int R_DIR_2 = 27; // (IN2 + IN3)

// ----------------------------------------------------
// PWM Settings
// ----------------------------------------------------
const int PWM_FREQ = 12000;
const int PWM_RES  = 8;   // 0..255

// ----------------------------------------------------
// PID Constants
// ----------------------------------------------------
float Kp = 0.7f;
float Ki = 0.00f;
float Kd = 3.0f; 

float integral = 0.0f;
float lastError = 0.0f;

// ניהול זמן לולאה
unsigned long nextPidTime = 0;

bool isRunning = false;

// ----------------------------------------------------
// הגדרות מהירות ופניות (Adaptive)
// ----------------------------------------------------
int MIN_SPEED = 160;
int MAX_SPEED_SET = 210;
int FRONT_WEAK_TH = 520; // סף לזיהוי סיבוב חד
float SPEED_BY_ERR = 0.10f; // מקדם האטה בסיבוב
float Kp_TURN_MULT = 1.40f; // בוסט להיגוי בסיבוב חד

// חזרה למסלול (Recovery)
int RECOVERY_TURN = 140;
int RECOVERY_BASE = 140;

// ----------------------------------------------------
// Debug
// ----------------------------------------------------
bool DEBUG_PRINT = true;
unsigned long lastPrint = 0;

// ----------------------------------------------------
// NVS & Tools
// ----------------------------------------------------
Preferences prefs;

static inline int clampi(int x, int lo, int hi) {
  return (x < lo) ? lo : (x > hi) ? hi : x;
}
static inline float clampf(float x, float lo, float hi) {
  return (x < lo) ? lo : (x > hi) ? hi : x;
}

// ----------------------------------------------------
// פונקציות מנוע
// ----------------------------------------------------

// פונקציית עזר לשליטה בצד אחד
void driveSide(int enPin, int pin1, int pin2, int pwmSigned) {
  int speed = abs(pwmSigned);
  speed = clampi(speed, 0, 255);

  if (pwmSigned > 0) {
    // נסיעה קדימה
    digitalWrite(pin1, HIGH);
    digitalWrite(pin2, LOW);
  } else if (pwmSigned < 0) {
    // נסיעה אחורה
    digitalWrite(pin1, LOW);
    digitalWrite(pin2, HIGH);
  } else {
    // עצירה
    digitalWrite(pin1, LOW);
    digitalWrite(pin2, LOW);
  }

  // שליחת ה-PWM לפין ה-Enable המשותף
  ledcWrite(enPin, speed);
}

void setMotors(int leftSigned, int rightSigned) {
  leftSigned  = clampi(leftSigned,  -255, 255);
  rightSigned = clampi(rightSigned, -255, 255);

  // שליחה לצד שמאל
  driveSide(L_EN, L_DIR_1, L_DIR_2, leftSigned);
  
  // שליחה לצד ימין
  driveSide(R_EN, R_DIR_1, R_DIR_2, rightSigned);
}

// ----------------------------------------------------
// קריאת חיישנים (עם סינון רעשים)
// ----------------------------------------------------
int readSmooth(int pin) {
  const int SAMPLES = 5;
  long sum = 0;
  for (int i = 0; i < SAMPLES; i++) {
    sum += analogRead(pin);
  }
  return (int)(sum / SAMPLES);
}

// נרמול קריאה 0-1000
int readWhiteStrengthCal(int pin, int black, int white) {
  int v = readSmooth(pin);
  if (white == black) return 0;
  long w = map(v, black, white, 0, 1000);
  return clampi((int)w, 0, 1000);
}

bool lineSeen(int wl, int wc, int wr) {
  return (wl > LINE_SEEN_TH) || (wc > LINE_SEEN_TH) || (wr > LINE_SEEN_TH);
}

float computeError(int wl, int wc, int wr) {
  long denom = (long)wl + (long)wc + (long)wr;
  if (denom < 30) return lastError; 
  long num = (long)wl * (-1000) + (long)wc * 0 + (long)wr * (1000);
  return (float)num / (float)denom;
}

// ----------------------------------------------------
// ניהול זיכרון (NVS)
// ----------------------------------------------------
void saveAll() {
  prefs.begin("racer", false);
  prefs.putInt("bl", BLACK_L); prefs.putInt("wl", WHITE_L);
  prefs.putInt("bc", BLACK_C); prefs.putInt("wc", WHITE_C);
  prefs.putInt("br", BLACK_R); prefs.putInt("wr", WHITE_R);
  prefs.putInt("th", LINE_SEEN_TH);
  prefs.putFloat("kp", Kp); prefs.putFloat("ki", Ki); prefs.putFloat("kd", Kd);
  prefs.putInt("mins", MIN_SPEED); prefs.putInt("maxs", MAX_SPEED_SET);
  prefs.putInt("fw", FRONT_WEAK_TH); prefs.putFloat("se", SPEED_BY_ERR);
  prefs.putFloat("km", Kp_TURN_MULT);
  prefs.putInt("rb", RECOVERY_BASE); prefs.putInt("rt", RECOVERY_TURN);
  prefs.putBool("dbg", DEBUG_PRINT);
  prefs.end();
  Serial.println("Saved to NVS");
}

void loadAll() {
  prefs.begin("racer", true);
  BLACK_L = prefs.getInt("bl", BLACK_L); WHITE_L = prefs.getInt("wl", WHITE_L);
  BLACK_C = prefs.getInt("bc", BLACK_C); WHITE_C = prefs.getInt("wc", WHITE_C);
  BLACK_R = prefs.getInt("br", BLACK_R); WHITE_R = prefs.getInt("wr", WHITE_R);
  LINE_SEEN_TH = prefs.getInt("th", LINE_SEEN_TH);
  Kp = prefs.getFloat("kp", Kp); Ki = prefs.getFloat("ki", Ki); Kd = prefs.getFloat("kd", Kd);
  MIN_SPEED = prefs.getInt("mins", MIN_SPEED); MAX_SPEED_SET = prefs.getInt("maxs", MAX_SPEED_SET);
  FRONT_WEAK_TH = prefs.getInt("fw", FRONT_WEAK_TH);
  SPEED_BY_ERR = prefs.getFloat("se", SPEED_BY_ERR); Kp_TURN_MULT = prefs.getFloat("km", Kp_TURN_MULT);
  RECOVERY_BASE = prefs.getInt("rb", RECOVERY_BASE); RECOVERY_TURN = prefs.getInt("rt", RECOVERY_TURN);
  DEBUG_PRINT = prefs.getBool("dbg", DEBUG_PRINT);
  prefs.end();
  Serial.println("Loaded from NVS");
}

void printStatus() {
  Serial.printf("RUN=%d | PID: P=%.2f I=%.2f D=%.2f\n", (int)isRunning, Kp, Ki, Kd);
  Serial.printf("Cal: L(%d-%d) C(%d-%d) R(%d-%d)\n", BLACK_L, WHITE_L, BLACK_C, WHITE_C, BLACK_R, WHITE_R);
}

// ----------------------------------------------------
// ניהול פקודות
// ----------------------------------------------------
String normalizeCmd(String msg) {
  msg.trim(); msg.toLowerCase();
  msg.replace(":", " ");
  while (msg.indexOf("  ") >= 0) msg.replace("  ", " ");
  msg.trim();
  return msg;
}

void processCommand(String msg) {
  msg = normalizeCmd(msg);
  if (msg.length() == 0) return;

  if (msg == "1" || msg == "g") { 
    isRunning = true; 
    Serial.println("GO"); 
    return; 
  }
  
  if (msg == "0" || msg == "x") { 
    isRunning = false; 
    setMotors(0, 0); 
    lastError = 0.0f;
    integral = 0.0f;
    Serial.println("STOP & RESET"); 
    return; 
  }

  if (msg == "save")   { saveAll(); return; }
  if (msg == "load")   { loadAll(); return; }
  if (msg == "status") { printStatus(); return; }

  // כיול מהיר
  if (msg == "bl") { BLACK_L = readSmooth(PIN_S_L); Serial.printf("BL=%d\n", BLACK_L); saveAll(); return; }
  if (msg == "bc") { BLACK_C = readSmooth(PIN_S_C); Serial.printf("BC=%d\n", BLACK_C); saveAll(); return; }
  if (msg == "br") { BLACK_R = readSmooth(PIN_S_R); Serial.printf("BR=%d\n", BLACK_R); saveAll(); return; }
  if (msg == "wl") { WHITE_L = readSmooth(PIN_S_L); Serial.printf("WL=%d\n", WHITE_L); saveAll(); return; }
  if (msg == "wc") { WHITE_C = readSmooth(PIN_S_C); Serial.printf("WC=%d\n", WHITE_C); saveAll(); return; }
  if (msg == "wr") { WHITE_R = readSmooth(PIN_S_R); Serial.printf("WR=%d\n", WHITE_R); saveAll(); return; }

  // פרמטרים
  String key, valStr;
  int sp = msg.indexOf(' ');
  if (sp >= 0) {
    key = msg.substring(0, sp); valStr = msg.substring(sp + 1);
  } else return;
  
  float f = valStr.toFloat();
  int iv = valStr.toInt();

  if (key == "p") { Kp = f; saveAll(); }
  else if (key == "i") { Ki = f; saveAll(); }
  else if (key == "d") { Kd = f; saveAll(); }
  else if (key == "t") { LINE_SEEN_TH = iv; saveAll(); }
  else if (key == "min") { MIN_SPEED = iv; saveAll(); }
  else if (key == "max") { MAX_SPEED_SET = iv; saveAll(); }
  else if (key == "fw") { FRONT_WEAK_TH = iv; saveAll(); } 
  else if (key == "km") { Kp_TURN_MULT = f; saveAll(); }
  Serial.println("OK");
}

class MyCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pC) override {
    auto v = pC->getValue();
    const char* c = v.c_str();
    if (c && c[0] != '\0') processCommand(String(c));
  }
};

// ----------------------------------------------------
// Setup
// ----------------------------------------------------
void setup() {
  Serial.begin(115200);

  // הגדרת פינים לכיוון (דיגיטליים)
  pinMode(L_DIR_1, OUTPUT);
  pinMode(L_DIR_2, OUTPUT);
  pinMode(R_DIR_1, OUTPUT);
  pinMode(R_DIR_2, OUTPUT);

  // הגדרת פינים למהירות (PWM)
  ledcAttach(L_EN, PWM_FREQ, PWM_RES);
  ledcAttach(R_EN, PWM_FREQ, PWM_RES);
  
  // חיישנים
  pinMode(PIN_S_L, INPUT);
  pinMode(PIN_S_C, INPUT);
  pinMode(PIN_S_R, INPUT);

  analogReadResolution(12);

  setMotors(0, 0);
  loadAll();
  
  // אתחול BLE
  BLEDevice::init(DEV_NAME);
  BLEServer *pServer = BLEDevice::createServer();
  BLEService *pService = pServer->createService(SERVICE_UUID);
  BLECharacteristic *pChar = pService->createCharacteristic(
    CHARACTERISTIC_UUID,
    BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
  );
  pChar->setCallbacks(new MyCallbacks());
  pService->start();
  BLEDevice::getAdvertising()->start();

  Serial.println("System Ready. Wiring: Parallel Control (EN=PWM).");
}

// ----------------------------------------------------
// Main Loop
// ----------------------------------------------------
void loop() {
  // 1. טיפול בתקשורת
  if (Serial.available()) {
    processCommand(Serial.readStringUntil('\n'));
  }

  // 2. בקרת זמן מדויקת
  unsigned long now = millis();
  if (now < nextPidTime) {
    return; 
  }
  nextPidTime = now + PID_INTERVAL_MS; 

  // 3. קריאת חיישנים
  int wl = readWhiteStrengthCal(PIN_S_L, BLACK_L, WHITE_L);
  int wc = readWhiteStrengthCal(PIN_S_C, BLACK_C, WHITE_C);
  int wr = readWhiteStrengthCal(PIN_S_R, BLACK_R, WHITE_R);

  if (DEBUG_PRINT && (now - lastPrint > 250)) {
      Serial.printf("S: %d %d %d | Err: %.2f\n", wl, wc, wr, lastError);
      lastPrint = now;
  }

  if (!isRunning) {
    setMotors(0, 0); 
    return;
  }

  // 4. לוגיקה ראשית
  bool seen = lineSeen(wl, wc, wr);
  float error = computeError(wl, wc, wr);

  // --- מצב חירום: איבוד קו ---
  if (!seen) {
    integral = 0; 
    int turnPwm = RECOVERY_TURN;
    if (lastError > 0) { 
       setMotors(RECOVERY_BASE + turnPwm, RECOVERY_BASE - turnPwm);
    } else { 
       setMotors(RECOVERY_BASE - turnPwm, RECOVERY_BASE + turnPwm);
    }
    return; 
  }

  // --- חישוב PID ---
  float absErr = fabs(error);
  bool frontWeak = (wc < FRONT_WEAK_TH);
  
  // מהירות דינאמית
  int dynSpeed = MAX_SPEED_SET - (int)(SPEED_BY_ERR * absErr);
  if (frontWeak) dynSpeed = (int)(dynSpeed * 0.80f); 
  dynSpeed = clampi(dynSpeed, MIN_SPEED, MAX_SPEED_SET);

  // הגברת היגוי בסיבובים חדים
  float effectiveKp = Kp;
  if (frontWeak) effectiveKp = Kp * Kp_TURN_MULT;

  // אינטגרל
  if (absErr < 200) integral += error;
  else integral = 0;
  integral = clampf(integral, -1000.0f, 1000.0f);

  // נגזרת
  float Dterm = (error - lastError); 
  lastError = error;

  // נוסחת הבקרה
  float u = (effectiveKp * error) + (Ki * integral) + (Kd * Dterm);

  int left  = dynSpeed + (int)u;
  int right = dynSpeed - (int)u;

  setMotors(left, right);
}
